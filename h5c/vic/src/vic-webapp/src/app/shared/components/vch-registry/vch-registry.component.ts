import {VchComponentBase} from '../vch-component-base';
import {Component, Input, OnInit} from '@angular/core';
import {ConfigureVchService} from '../../../configure/configure-vch.service';
import {FormArray, FormBuilder, Validators} from '@angular/forms';
import {CreateVchWizardService} from '../../../create-vch-wizard/create-vch-wizard.service';
import {I18nService} from '../../i18n.service';
import {GlobalsService} from '../../globals.service';
import {serverCertSourceAutogenerated, VchRegistryView} from '../../../interfaces/vch';
import {Observable} from 'rxjs/Observable';
import {numberPattern} from '../../utils/validators';
import {whiteListRegistryPattern} from '../../utils';
import {CertificateInfo, parseCertificatePEMFileContent} from '../../utils/certificates';

@Component({
  selector: 'vic-vch-registry',
  templateUrl: './vch-registry.component.html',
  styleUrls: ['./vch-registry.component.scss']
})
export class VchRegistryComponent extends VchComponentBase implements OnInit {

  @Input() model: VchRegistryView;
  protected readonly apiModelKey = 'registry';
  protected readonly initialModel: VchRegistryView = {
    registryCa: [],
    insecureRegistry: [],
    whitelistRegistry: [],
    useWhitelistRegistry: false
  };

  public registryCaContents: any[] = [];
  public registryCaError: string = null;
  private _isSetup = false;

  constructor(
    protected formBuilder: FormBuilder,
    protected createWzService: CreateVchWizardService,
    protected globalsService: GlobalsService,
    protected configureService: ConfigureVchService,
    public i18n: I18nService
  ) {
    super(formBuilder, createWzService, globalsService, configureService);
    this.initCurrentForm(this.initialModel);
  }

  ngOnInit() {
    super.ngOnInit();
  }

  /**
   * Updates the current form based on the input model in case of configure flow and/or based on the initial model in case of creation flow.
   */
  protected initCurrentForm(model: VchRegistryView) {
    this.form = this.formBuilder.group({
      useWhitelistRegistry: model.useWhitelistRegistry,
      insecureRegistries: this.formBuilder.array(model.insecureRegistry && model.insecureRegistry.length > 0 ? [
        ...(model.insecureRegistry
          .filter( registry => model.whitelistRegistry.indexOf(registry) === -1)
          .map(registry => this.createNewFormArrayEntry('insecureRegistries', registry))),
        this.createNewFormArrayEntry('insecureRegistries')
      ] : [
        this.createNewFormArrayEntry('insecureRegistries')
      ]),
      whitelistRegistries: this.formBuilder.array(model.whitelistRegistry && model.whitelistRegistry.length > 0 ? [
        ...(model.whitelistRegistry.map(registry =>
            this.createNewFormArrayEntry('whitelistRegistries', registry,
              model.insecureRegistry.indexOf(registry) !== -1 ? 'insecure' : 'secure')))
      ] : [
        this.createNewFormArrayEntry('whitelistRegistries')
      ]),
      registryCas: this.formBuilder.array(model.registryCa && model.registryCa.length > 0 ? [
        ...(model.registryCa.map(cert => this.createNewFormArrayEntry('registryCas', cert.name))),
        this.createNewFormArrayEntry('registryCas')
      ] : [
        this.createNewFormArrayEntry('registryCas')
      ])
    });

    this.registryCaContents = model.registryCa ? model.registryCa : [];
    this.updateWhitelistRegistryStatus(model.useWhitelistRegistry);
  }

  /**
   * Updates the internal component model.
   * This method will be called right after component inits and every time a form value changes, in order to keep the internal
   * model in sync with the form values.
   */
  protected updateCurrentModel() {
    if (this.form.valid || this.readOnly) {
      const useWhitelistRegistryValue = this.form.get('useWhitelistRegistry').value;
      const insecureRegistriesValue = this.form.get('insecureRegistries').value;
      const whitelistRegistriesValue = this.form.get('whitelistRegistries').value;
      const currentModel: VchRegistryView = {
        registryCa: [],
        insecureRegistry: [],
        whitelistRegistry: [],
        useWhitelistRegistry: useWhitelistRegistryValue
      };

      // If user doesn't use white list registries...
      if (!useWhitelistRegistryValue) {
        // We want to make sure that each insecure registry is added to the payload even without a port (only with the IP).
        currentModel.insecureRegistry = insecureRegistriesValue
          .filter(val => val['insecureRegistryIp'])
          .map(val => (val['insecureRegistryPort'] === '' ?
            `${val['insecureRegistryIp']}` : `${val['insecureRegistryIp']}:${val['insecureRegistryPort']}`));
      } else {
        // If user decides to use whitelist registries...
        // We want to split them into whitelisted registries and insecure registries
        const white = [];
        const insecure = [];
        whitelistRegistriesValue
          .filter(val => val['whitelistRegistry'] )
          .forEach(val => {
            if (val['whitelistRegType'] === 'secure') {
              white.push(val['whitelistRegistry']);
            } else {
              insecure.push(val['whitelistRegistry']);
            }});

        // Finally we update the currentModel with the split registries
        currentModel.whitelistRegistry = white;
        currentModel.insecureRegistry = insecure;
      }

      currentModel.registryCa = this.registryCaContents;

      this.model = currentModel;
    }
  }

  onCommit(): Observable<{ [key: string]: VchRegistryView }> {
    return Observable.of({[this.apiModelKey]: this.model});
  }

  onPageLoad() {
    if (this._isSetup) {
      return;
    }

    this.form.get('useWhitelistRegistry').valueChanges
      .subscribe(v => this.updateWhitelistRegistryStatus(v));

    this._isSetup = true;
  }

  // ------------------------------------------------------------------------------------

  private updateWhitelistRegistryStatus(source: boolean) {
    if (source) {
      this.form.get('whitelistRegistries').enable();
    } else {
      this.form.get('whitelistRegistries').disable();
    }
  }

  addNewFormArrayEntry(controlName: string) {
    const control = this.form.get(controlName) as FormArray;
    if (!control) {
      return;
    }
    control.push(this.createNewFormArrayEntry(controlName));
  }

  createNewFormArrayEntry(controlName: string, value: string = '', type: string = 'secure') {
    switch (controlName) {
      case 'insecureRegistries': {
        const insecureReg = value.split(':');
        return this.formBuilder.group({
          insecureRegistryIp: insecureReg[0],
          insecureRegistryPort: [
            insecureReg[1],
            [
              Validators.maxLength(5),
              Validators.pattern(numberPattern)
            ]
          ]
        });
      }
      case 'whitelistRegistries': {
        return this.formBuilder.group({
          whitelistRegistry: [value, [
            Validators.required,
            Validators.pattern(whiteListRegistryPattern)
          ]],
          whitelistRegType: type
        });
      }
      case 'registryCas': {
        return this.formBuilder.group({
          registryCa: value
        });
      }
    }
  }

  removeFormArrayEntry(controlName: string, index: number) {
    const control = this.form.get(controlName) as FormArray;
    if (!control) {
      return;
    }

    if (controlName === 'registryCas') {
      if (index > 0 || (index === 0 && control.controls.length > 1)) {
        control.removeAt(index);
        this.registryCaContents.splice(index, 1);
      } else {
        this.registryCaContents.shift();
        control.controls[index].reset();
      }
    } else {
      control.removeAt(index);
    }
  }

  /**
   * On Change event read the content of the file and add it to the
   * corresponding array or overwrite the value at the given index
   */
  addFileContent(evt: Event, targetField: string, index: number, isLast: boolean) {
    const fr = new FileReader();
    const fileList: FileList = evt.target['files'];

    const fileReaderOnLoadFactory = (filename: string) => {
      let certificate: CertificateInfo;

      switch (targetField) {
        case 'registryCas': return (event) => {
          let targetArray: any[];

          targetArray = this.registryCaContents;

          try {
            certificate = parseCertificatePEMFileContent(event.target.result);
          } catch (e) {
            this.registryCaError = this.i18n.translate('vch.registry.failedToParseCertPem');
            return;
          }

          if (isLast) {
            this.addNewFormArrayEntry(targetField);
          }

          const value = {
            name: filename,
            content: event.target.result,
            expires: certificate.expires
          };

          if (targetArray[index]) {
            // overwrite if value already exists at this index
            targetArray[index] = value;
          } else {
            targetArray.push(value);
          }
        };
      }
    };

    // since input is without the 'multiple' attribute we are sure that
    // only one entry will be available under FileList
    const fileInstance: File = fileList[0];

    if (targetField === 'registryCas') {
      this.registryCaError = fileInstance ? null : this.i18n.translate('vch.registry.failedToLoadCertPem');
    }
    fr.onload = fileReaderOnLoadFactory(fileInstance.name);
    fr.readAsText(fileInstance);
  }

  /**
   * Clear the file reader error messages. This method is called when clr-tab's
   * clrTabsCurrentTabContentChanged event is fired
   */
  clearFileReaderError() {
    this.registryCaError = null;
  }

}
